import { ExploitType, type VulnerabilityInfo } from "./ExploitTypes";

export namespace ExploitDatabase {
	const vulnerabilities: Map<number, VulnerabilityInfo[]> = new Map([
		// SC7731 Series - Early chips, most are vulnerable
		[
			0x7731,
			[
				{
					type: ExploitType.FdlSignatureBypass,
					name: "SC7731 Signature Bypass",
					description:
						"Early SC7731 versions do not correctly verify FDL signature",
					successRate: 4,
					affectedChips: ["SC7731", "SC7731C", "SC7731E"],
				},
				{
					type: ExploitType.MemoryRead,
					name: "SC7731 Memory Read",
					description: "Sensitive memory areas can be read via BSL commands",
					successRate: 3,
					affectedChips: ["SC7731"],
				},
			],
		],

		// SC9820 Series
		[
			0x9820,
			[
				{
					type: ExploitType.BslOverflow,
					name: "SC9820 BSL Overflow",
					description:
						"Buffer overflow vulnerability exists in BSL handshake phase",
					successRate: 3,
					affectedChips: ["SC9820", "SC9820E"],
				},
			],
		],

		// SC9830 Series
		[
			0x9830,
			[
				{
					type: ExploitType.Downgrade,
					name: "SC9830 Downgrade Attack",
					description:
						"Older FDL versions can be used to bypass security checks",
					successRate: 3,
					affectedChips: ["SC9830", "SC9830A"],
				},
			],
		],

		// SC9832 Series
		[
			0x9832,
			[
				{
					type: ExploitType.HdlcOverflow,
					name: "SC9832 HDLC Overflow",
					description: "Integer overflow exists in HDLC frame parsing",
					successRate: 2,
					affectedChips: ["SC9832", "SC9832E"],
				},
			],
		],

		// SC9850 Series
		[
			0x9850,
			[
				{
					type: ExploitType.DebugMode,
					name: "SC9850 Debug Mode",
					description: "Certain firmware versions allow debug mode activation",
					successRate: 2,
					affectedChips: ["SC9850KA"],
				},
			],
		],

		// SC9863 Series
		[
			0x9863,
			[
				{
					type: ExploitType.CustomExecNoVerify,
					name: "SC9863A Signature Bypass",
					description: "Use custom_exec_no_verify to bypass signature check",
					successRate: 4,
					affectedChips: ["SC9863A"],
					execAddr: 0x65012f48,
					payloadFile: "exploit_65012f48.bin",
				},
			],
		],

		// T610/T612/T616/T618 Series
		[
			0x0610,
			[
				{
					type: ExploitType.CustomExecNoVerify,
					name: "T610 Signature Bypass",
					description: "Use custom_exec_no_verify to bypass signature check",
					successRate: 4,
					affectedChips: ["T610", "T612", "T616", "T618", "UMS512"],
					execAddr: 0x65012f48,
					payloadFile: "exploit_65012f48.bin",
				},
			],
		],

		// T700/T760/T770 Series - Requires exploit
		[
			0x0700,
			[
				{
					type: ExploitType.CustomExecNoVerify,
					name: "T700 Signature Bypass",
					description: "Use custom_exec_no_verify to bypass signature check",
					successRate: 4,
					affectedChips: ["T700", "T760", "T770"],
					execAddr: 0x65012f48,
					payloadFile: "exploit_65012f48.bin",
				},
			],
		],
		[
			0x0760,
			[
				{
					type: ExploitType.CustomExecNoVerify,
					name: "T760 Signature Bypass",
					description:
						"Use custom_exec_no_verify to bypass signature check (Verified)",
					successRate: 5,
					affectedChips: ["T760"],
					execAddr: 0x65012f48,
					payloadFile: "exploit_65012f48.bin",
				},
			],
		],
		[
			0x0770,
			[
				{
					type: ExploitType.CustomExecNoVerify,
					name: "T770 Signature Bypass",
					description: "Use custom_exec_no_verify to bypass signature check",
					successRate: 4,
					affectedChips: ["T770"],
					execAddr: 0x65012f48,
					payloadFile: "exploit_65012f48.bin",
				},
			],
		],

		// T606 Series
		[
			0x0606,
			[
				{
					type: ExploitType.MemoryRead,
					name: "T606 Memory Read",
					description: "Protected memory can be read under specific conditions",
					successRate: 2,
					affectedChips: ["T606"],
				},
			],
		],
	]);

	/**
	 * Get vulnerabilities for a specific chip
	 */
	export function getVulnerabilities(chipId: number): VulnerabilityInfo[] {
		const baseId = chipId > 0xffff ? chipId >> 16 : chipId;
		return vulnerabilities.get(chipId) || vulnerabilities.get(baseId) || [];
	}

	/**
	 * Check if chip requires exploit for FDL download
	 */
	export function requiresExploit(chipId: number): boolean {
		const baseId = chipId > 0xffff ? chipId >> 16 : chipId;

		// Chips that require signature bypass
		const exploitChips = [
			0x9850, // SC9850K
			0x9853, // SC9853i
			0x9860, // SC9860G
			0x9861, // SC9861
			0x9863, // SC9863A
			0x8581, // SC8581A
			0x0610, // T610
			0x0612, // T612
			0x0616, // T616
			0x0618, // T618
			0x0512, // UMS512
			0x0700, // T700
			0x0760, // T760
			0x0770, // T770
		];

		return exploitChips.includes(chipId) || exploitChips.includes(baseId);
	}

	/**
	 * Get exec address for custom_exec_no_verify bypass
	 */
	export function getExecAddress(chipId: number): number {
		const baseId = chipId > 0xffff ? chipId >> 16 : chipId;

		// Chips with known exec addresses for signature bypass
		const execAddresses: Record<number, number> = {
			39011: 0x65012f48, // SC9863A
			1552: 0x65012f48, // T610
			1554: 0x65012f48, // T612
			1558: 0x65012f48, // T616
			1560: 0x65012f48, // T618
			1298: 0x65012f48, // UMS512
			38995: 0x65012f48, // SC9853i
			34177: 0x65012f48, // SC8581A
			38992: 0x65012000, // SC9850K (may need verification)
			39008: 0x65012000, // SC9860G (may need verification)
			39009: 0x65012000, // SC9861 (may need verification)
			1792: 0x65012f48, // T700
			1888: 0x65012f48, // T760 (Verified)
			1904: 0x65012f48, // T770
		};

		return execAddresses[chipId] || execAddresses[baseId] || 0;
	}

	/**
	 * Check if chip needs exec_no_verify bypass
	 */
	export function needsExecBypass(chipId: number): boolean {
		return getExecAddress(chipId) > 0;
	}

	/**
	 * Get payload filename for exploit
	 */
	export function getPayloadFile(chipId: number): string | null {
		const execAddr = getExecAddress(chipId);
		if (execAddr === 0) return null;

		// Format: custom_exec_no_verify_XXXXXXXX.bin or exploit_XXXXXXXX.bin
		return `exploit_${execAddr.toString(16).padStart(8, "0")}.bin`;
	}
}
