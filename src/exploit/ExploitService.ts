import { readFile } from "node:fs/promises";
import { join } from "node:path";
import { ChipSets } from "../utils/ChipSets";
import { ExploitDatabase } from "./ExploitDatabase";
import {
	type ExploitResult,
	ExploitType,
	type VulnerabilityCheckResult,
} from "./ExploitTypes";

export class ExploitService {
	private exploitResourcePath: string;

	constructor(resourcePath = "resources/exploits") {
		this.exploitResourcePath = resourcePath;
	}

	/**
	 * Check chip for vulnerabilities
	 */
	checkVulnerabilities(chipId: number): VulnerabilityCheckResult {
		const vulnerabilities = ExploitDatabase.getVulnerabilities(chipId);
		const requiresExploit = ExploitDatabase.requiresExploit(chipId);
		const execAddr = ExploitDatabase.getExecAddress(chipId);
		const chipName = ChipSets.getName(chipId);

		return {
			chipId,
			chipName,
			vulnerabilities,
			requiresExploit,
			execAddr,
		};
	}

	/**
	 * Load exploit payload from file
	 */
	async loadExploitPayload(chipId: number): Promise<Buffer | null> {
		const payloadFile = ExploitDatabase.getPayloadFile(chipId);
		if (!payloadFile) {
			console.log(
				`[Exploit] No payload needed for chip 0x${chipId.toString(16)}`,
			);
			return null;
		}

		try {
			const payloadPath = join(this.exploitResourcePath, payloadFile);
			const payload = await readFile(payloadPath);
			console.log(
				`[Exploit] Loaded payload: ${payloadFile} (${payload.length} bytes)`,
			);
			return payload;
		} catch (error) {
			console.error(`[Exploit] Failed to load payload ${payloadFile}:`, error);
			return null;
		}
	}

	/**
	 * Build custom_exec_no_verify payload
	 * This is a simplified version - full implementation would include
	 * the actual exploit code generation
	 */
	buildCustomExecPayload(execAddr: number, targetAddr: number): Buffer {
		// Placeholder: In a real implementation, this would generate
		// ARM/Thumb assembly code to bypass signature verification
		// Reference: custom_exec_no_verify implementation strategy

		console.log(
			`[Exploit] Building custom_exec_no_verify payload: exec=0x${execAddr.toString(16)}, target=0x${targetAddr.toString(16)}`,
		);

		// Simple payload structure:
		// 1. Patch verification function at execAddr to return success
		// 2. Jump to target address

		// This is a placeholder - actual exploit code would be more complex
		const payload = Buffer.alloc(256);

		// Write exec address
		payload.writeUInt32LE(execAddr, 0);
		payload.writeUInt32LE(targetAddr, 4);

		return payload;
	}

	/**
	 * Apply signature bypass exploit
	 */
	async applySignatureBypass(
		chipId: number,
		sendCommand: (addr: number, data: Buffer) => Promise<boolean>,
	): Promise<ExploitResult> {
		const chipName = ChipSets.getName(chipId);
		const execAddr = ExploitDatabase.getExecAddress(chipId);

		if (execAddr === 0) {
			return {
				success: false,
				type: ExploitType.CustomExecNoVerify,
				message: "Chip does not require signature bypass",
				chipId,
			};
		}

		console.log(`[Exploit] Applying signature bypass for ${chipName}...`);
		console.log(`[Exploit] Exec address: 0x${execAddr.toString(16)}`);

		// Try to load exploit payload
		const payload = await this.loadExploitPayload(chipId);

		if (!payload) {
			console.warn(
				`[Exploit] No exploit payload found, attempting generic bypass...`,
			);
			// Generate generic payload
			const genericPayload = this.buildCustomExecPayload(execAddr, 0x65000800);

			try {
				const success = await sendCommand(execAddr, genericPayload);
				if (success) {
					return {
						success: true,
						type: ExploitType.CustomExecNoVerify,
						message: "Signature bypass applied (generic payload)",
						chipId,
						execAddr,
					};
				}
			} catch (error) {
				return {
					success: false,
					type: ExploitType.CustomExecNoVerify,
					message: `Exploit failed: ${error}`,
					chipId,
					execAddr,
				};
			}
		}

		// Use loaded payload
		try {
			const success = await sendCommand(execAddr, payload);
			if (success) {
				console.log("[Exploit] âœ… Signature bypass successful!");
				return {
					success: true,
					type: ExploitType.CustomExecNoVerify,
					message: "Signature bypass applied successfully",
					chipId,
					execAddr,
				};
			}
			return {
				success: false,
				type: ExploitType.CustomExecNoVerify,
				message: "Exploit execution failed",
				chipId,
				execAddr,
			};
		} catch (error) {
			return {
				success: false,
				type: ExploitType.CustomExecNoVerify,
				message: `Exploit failed: ${error}`,
				chipId,
				execAddr,
			};
		}
	}

	/**
	 * Check if signature bypass is needed
	 */
	needsSignatureBypass(chipId: number): boolean {
		return ExploitDatabase.needsExecBypass(chipId);
	}

	/**
	 * Get exploit statistics
	 */
	getExploitStats() {
		const allVulnerabilities = [];
		let vulnerableChips = 0;

		// Count vulnerabilities across all known chips
		for (let chipId = 0; chipId <= 0xffff; chipId++) {
			const vulns = ExploitDatabase.getVulnerabilities(chipId);
			if (vulns.length > 0) {
				vulnerableChips++;
				allVulnerabilities.push(...vulns);
			}
		}

		return {
			totalVulnerabilities: allVulnerabilities.length,
			vulnerableChips,
			exploitTypes: new Set(allVulnerabilities.map((v) => v.type)).size,
		};
	}
}
